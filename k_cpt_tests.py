# -*- coding: utf-8 -*-
"""k_cpt_tests.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-4Z4nQxIqiob-kX2yk1ue91yoxfiUcGD
"""

#!pip install cpt

import random
import operator
from cpt.cpt import Cpt
import numpy as np
from itertools import permutations, combinations
import pickle
import csv

#@title Elements generation

#base=["A","B","C","D"]  #"A",B1   "B",B2     "C",B3    "D",B4
#sides=["E","F","G","H"]   # "E" L14 ,"F" L12 ,"G" L23 ,"H" L34
#top=["I","J","K","L"]   #"I" T1,    "J" T2,    "K" T3,    "L" T4

base=["B1","B2","B3","B4"]
sides=["L14","L12","L23","L34"]
top=["T1","T2","T3","T4"]



cube_elements=base+sides+top
objects_number=len(cube_elements)
print(objects_number, cube_elements)

num_trials=5000000

#@title Generation of possible paths
possible_paths=[]
for i in range(num_trials):
  elements=base+sides+top
  cube=[]
  while(len(elements)>0):
    choice=random.randrange(len(elements))
    selected_element=elements[choice]
    if selected_element in ["B1","B2","B3","B4"]:
      cube.append(selected_element)
      elements.pop(choice)
    if selected_element=="L14" and ("B1" in cube and "B4" in cube):
      cube.append(selected_element)
      elements.pop(choice)
    if selected_element=="L12" and ("B2" in cube and "B1" in cube):
      cube.append(selected_element)
      elements.pop(choice)
    if selected_element=="L23" and ("B3" in cube and "B2" in cube):
      cube.append(selected_element)
      elements.pop(choice)
    if selected_element=="L34" and ("B4" in cube and "B3" in cube):
      cube.append(selected_element)
      elements.pop(choice)
    if selected_element=="T1" and ("L14" in cube and "L12" in cube):
      cube.append(selected_element)
      elements.pop(choice)
    if selected_element=="T2" and ("L12" in cube and "L23" in cube):
      cube.append(selected_element)
      elements.pop(choice)
    if selected_element=="T3" and ("L23" in cube and "L34" in cube):
      cube.append(selected_element)
      elements.pop(choice)
    if selected_element=="T4" and ("L34" in cube and "L14" in cube):
      cube.append(selected_element)
      elements.pop(choice)

  possible_paths.append(cube)

seen_orders = set()

for sublist in possible_paths:
    order_tuple = tuple(sublist)  # Convert list to tuple (hashable)
    if order_tuple in seen_orders:
        continue
    seen_orders.add(order_tuple)

possible_paths = seen_orders

print(len(possible_paths))


#print(possible_paths)

#@title Constraint check

def check_constraint(sequence):

  for i in sequence:
    if i in ["B1","B2","B3","B4"]:
      continue
    elif i=="L14" and not ("B1" in sequence and "B4" in sequence):
      #print("i==L14 and not (B1 in sequence and B4 in sequence)")
      return False
    elif i=="L12" and not ("B2" in sequence and "B1" in sequence):
      #print("i==L12 and not (B2 in sequence and B1 in sequence)")
      return False
    elif i=="L23" and not ("B3" in sequence and "B2" in sequence):
      #print("i==L23 and not (B3 in sequence and B2 in sequence)")
      return False
    elif i=="L34" and not ("B4" in sequence and "B3" in sequence):
      #print("i==L34 and not (B4 in sequence and B3 in sequence)")
      return False
    elif i=="T1" and not ("L14" in sequence and "L12" in sequence):
      #print("i==T1 and not (L14 in sequence and L12 in sequence)")
      return False
    elif i=="T2" and not ("L12" in sequence and "L23" in sequence):
      #print("i==T2 and not (L12 in sequence and L23 in sequence)")
      return False
    elif i=="T3" and not ("L23" in sequence and "L34" in sequence):
      #print("i==T3 and not (L23 in sequence and L34 in sequence)")
      return False
    elif i=="T4" and not ("L34" in sequence and "L14" in sequence):
      #print("i==T4 and not (L34 in sequence and L14 in sequence)")
      return False

  #print("Constraint checked")
  return True

#@title Datasets and trees for each k
def train_trees(possible_paths):

  trees = []
  k_datasets = []

  for i in range(12):
    model = Cpt()
    k_dataset = []

    for j in possible_paths:
      k_dataset.append(j[0:i+1])

    k_datasets.append(k_dataset)
    model.fit(k_dataset)
    trees.append(model)

  return trees, k_datasets

#print(k_datasets[11])

#@title Train and save

trees, k_datasets = train_trees(possible_paths)

with open('trained_trees.pickle',"wb") as output:
  pickle.dump(trees, output)

#@title Inform decision
#stringa=["B1","B2","L12"]
def inform_decision(model, sequence,dataset):
  similar_sequences=model.find_similar_sequences(sequence)
  #print(similar_sequences)

  #print("Sequenze simili")
  #for i in similar_sequences:
  #  print(i)
  #print("---------------")

  print("\nCpt tree predictions")
  print(model.predict_k([sequence], 15))

  for i in similar_sequences:
    i.reverse()

  consequent_sequences_list=[]
  for i in similar_sequences[:]:
    max=100
    for j in sequence:
      if j in i:
        pos=i.index(j)
        #print(j,i, pos)
        if pos<max:
          max=pos
        #print(i[:pos])
    candidate=i[:max]
    #print(candidate)
    consequent_sequences_list.append(candidate)

  for i in consequent_sequences_list:
    i.reverse()

  #print(consequent_sequences_list)


  elements={}
  for i in consequent_sequences_list[:]:
    #print("-",i)
    for j in i:
      #print(j)
      if j not in elements.keys():
        elements[j]=1
      else:
        elements[j]=elements[j]+1
    #print(elements)
  sorted_elements=sorted(elements.items(),key=operator.itemgetter(1), reverse=True)

  if sorted_elements != []:
    print("Support of predicted elements")
    print(sorted_elements)
  else:
    elements={}
    for i in dataset:
    #print("-",i)
      for j in i:
        #print(j)
        if j not in elements.keys():
          elements[j]=1
        else:
          elements[j]=elements[j]+1
      #print(elements)
    sorted_elements=sorted(elements.items(),key=operator.itemgetter(1), reverse=True)
    print("Confidence of predicted elements")
    print(sorted_elements)

  '''
  num_elements = 0
  for i in sorted_elements:
    num_elements = num_elements + i[1]

  sorted_probabilities = sorted_elements.copy()
  for i in range(len(sorted_probabilities)):
    lst = list(sorted_probabilities[i])
    lst[1] = sorted_probabilities[i][1]/num_elements
    sorted_probabilities[i] = tuple(lst)
    #i[1] = i[1]/num_elements
  print("Probabilities of  predicted elements")
  print(sorted_probabilities)
  '''
  #return sorted_probabilities

#@title Good case
test_iteration = 25
split_percentage = [100, 80, 60, 40, 20]
'''
for n in split_percentage:
  print("Testing model with", n, "% of training set")

  performances = []

  for i in range(test_iteration):

    selected_training_set = random.sample(list(possible_paths), int((len(list(possible_paths)))*(n/100)))
    trees, k_datasets = train_trees(selected_training_set)

    correct_prediction = 0
    num_prediction = 0

    for j in ["B1", "B2", "B3", "B4"]:

      sequence = [j]

      z = 0

      while (z<10):
        #print("\nFeeding ", sequence)
        model = trees[int(len(sequence)+1)]

        k_dataset = k_datasets[int(len(sequence)+1)]

        new_element = model.predict_k([sequence], 15)[0][0]

        #inform_decision(model, sequence, k_dataset)
        #probs = fill_probabilities(cube,prob)
        #sample = np.random.choice(cube, size=1, p=probs)
        #print(sample)
        sequence.append(new_element)

        if (len(sequence)>1):
          constraint_checked = check_constraint(sequence)
          if constraint_checked:
            correct_prediction = correct_prediction + 1
          else:
            print("Constraint check failed:", sequence)
            inform_decision(model, sequence, k_dataset)
            num_prediction = num_prediction + 1
            break

          num_prediction = num_prediction + 1

        z = z + 1
    #print("Correct prediction ", correct_prediction)
    #print("Num prediction ", num_prediction)
    performances.append(correct_prediction/num_prediction)

  #print(performances)
  print(performances)
  print("Accuracy: mean=", np.mean(np.array(performances)), "std=",np.std(np.array(performances)), "min=",np.min(np.array(performances)), "max=",np.max(np.array(performances)))
'''
#@title Methods for testing with misdetections
def introduce_misdetection(sequence, elements_to_remove):

  if "B1" in elements_to_remove: #we want to midetect it
    if "B1" in sequence: #it is already in the sequence
      if "L12" in sequence or "L14" in sequence: #there are elements that can inform about its presence
        sequence.remove("B1")
  if "B2" in elements_to_remove:
    if "B2" in sequence:
      if "L12" in sequence or "L14" in sequence:
        sequence.remove("B2")
  if "B3" in elements_to_remove:
    if "B3" in sequence:
      if "L23" in sequence or "L34" in sequence:
        sequence.remove("B3")
  if "B4" in elements_to_remove:
    if "B4" in sequence:
      if "L34" in sequence or "L14" in sequence:
        sequence.remove("B4")
  if "L12" in elements_to_remove:
    if "L12" in sequence:
      if "T1" in sequence or "T2" in sequence:
        sequence.remove("L12")
  if "L23" in elements_to_remove:
    if "L23" in sequence:
      if "T2" in sequence or "T3" in sequence:
        sequence.remove("L23")
  if "L34" in elements_to_remove:
    if "L34" in sequence:
      if "T3" in sequence or "T4" in sequence:
        sequence.remove("L34")
  if "L14" in elements_to_remove:
    if "L14" in sequence:
      if "T1" in sequence or "T4" in sequence:
        sequence.remove("L14")
  return sequence

def pseudo_check_constraints(sequence, elements_undetected):
  for i in sequence:
    if i in ["B1","B2","B3","B4"]:
      continue
    if "B1" not in elements_undetected and "B4" not in elements_undetected:
      if i=="L14" and not ("B1" in sequence and "B4" in sequence):
        #print("i==L14 and not (B1 in sequence and B4 in sequence)")
        return False
    elif "B1" not in elements_undetected and "B2" not in elements_undetected:
      if i=="L12" and not ("B1" in sequence and "B2" in sequence):
        #print("i==L14 and not (B1 in sequence and B4 in sequence)")
        return False
    elif "B3" not in elements_undetected and "B2" not in elements_undetected:
      if i=="L23" and not ("B3" in sequence and "B2" in sequence):
        #print("i==L14 and not (B1 in sequence and B4 in sequence)")
        return False
    elif "B3" not in elements_undetected and "B4" not in elements_undetected:
      if i=="L34" and not ("B3" in sequence and "B4" in sequence):
        #print("i==L14 and not (B1 in sequence and B4 in sequence)")
        return False
    elif "L12" not in elements_undetected and "L14" not in elements_undetected:
      if i=="T1" and not ("L14" in sequence and "L12" in sequence):
        #print("i==T1 and not (L14 in sequence and L12 in sequence)")
        return False
    elif "L23" not in elements_undetected and "L12" not in elements_undetected:
      if i=="T2" and not ("L23" in sequence and "L12" in sequence):
        #print("i==T1 and not (L14 in sequence and L12 in sequence)")
        return False
    elif "L23" not in elements_undetected and "L34" not in elements_undetected:
      if i=="T3" and not ("L23" in sequence and "L34" in sequence):
        #print("i==T1 and not (L14 in sequence and L12 in sequence)")
        return False
    elif "L34" not in elements_undetected and "L14" not in elements_undetected:
      if i=="T4" and not ("L34" in sequence and "L14" in sequence):
        #print("i==T1 and not (L14 in sequence and L12 in sequence)")
        return False

  return True

#@title Misdetections




test_iteration = 500
split_percentage = [100, 80, 60, 40, 20]

for n in split_percentage:

  print("Testing model with ", n, "% of training set")

  performance = []
  A_error = []
  B_error = []
  C_error = []
  for m in range(6):

    if m==0:
      continue

    print("Testing model with ", m, " misdetection")
    #misdetected = combinations(cube, m) #Elements to be misdetected
    misdetected = combinations(cube_elements[0:9], m) #Elements to be misdetected

    performances = []
    first_errors = []
    second_errors = []
    third_errors = []
    for i in range(test_iteration):

      selected_training_set = random.sample(list(possible_paths), int((len(list(possible_paths)))*(n/100)))
      trees, k_datasets = train_trees(selected_training_set)

      for k in misdetected:

        #print("Testing misdetection of: ", k)

        correct_prediction = 0
        num_prediction = 0
        first_error = 0
        second_error = 0
        third_error = 0
        task_successful = True

        for j in ["B1", "B2", "B3", "B4"]: #Starting point of all test cases

          sequence = [j]

          elements_introduced = {keys: False for keys in k}

          z = 0

          while (z<10-m):

            sequence = introduce_misdetection(sequence, k)
            #print(len(sequence))
            #print("\nFeeding ", sequence)
            model = trees[int(len(sequence)+1)]

            k_dataset = k_datasets[int(len(sequence)+1)]

            new_element = model.predict_k([sequence], 15)[0][0]
            #print("Predicted new element", new_element)
            #inform_decision(model, sequence, k_dataset)

            if new_element in sequence:
              task_successful = False # Type A: the same element appears twice in sequence
              first_error = first_error + 1
              break
            if new_element not in k: 
              sequence.append(new_element)
            else:
              if elements_introduced[new_element] == False:
                sequence.append(new_element)
                elements_introduced[new_element] = True
              else:
                task_successful = False # Type B: the occluded element is inserted again
                second_error = second_error + 1
                #print("Constraint check failed:", sequence)
                break


            if (len(sequence)>1):
              constraint_checked = pseudo_check_constraints(sequence, k)
              #print("Constraint check", constraint_checked)
              if not constraint_checked:
                task_successful = False #Type C: Constraints not respected
                #print("Constraint check failed:", sequence)
                #inform_decision(model, sequence, k_dataset)
                third_error = third_error + 1
                break

            z = z + 1

          num_prediction = num_prediction + 1
          if task_successful:
            #print("Entered here")
            correct_prediction = correct_prediction + 1

        #print("Correct prediction ", correct_prediction)
        #print("Num prediction ", num_prediction)
          performances.append(correct_prediction/num_prediction)
          first_errors.append(first_error/num_prediction)
          second_errors.append(second_error/num_prediction)
          third_errors.append(third_error/num_prediction)
          

    #print(len(performances),performances)
    performance.append(np.mean(np.array(performances)))
    print("Accuracy with", m, "misdetections: mean=", np.mean(np.array(performances)), "std=",np.std(np.array(performances)), "min=",np.min(np.array(performances)), "max=",np.max(np.array(performances)))
    print("Errors Means: Type A=", np.mean(np.array(first_errors)), "Type B=",np.mean(np.array(second_errors)), "Type C=",np.mean(np.array(third_errors)))
    print("Errors SDs: Type A=", np.std(np.array(first_errors)), "Type B=",np.std(np.array(second_errors)), "Type C=",np.std(np.array(third_errors)))

    accuracy_mean = np.mean(np.array(performances))
    accuracy_std = np.std(np.array(performances))
    accuracy_min = np.min(np.array(performances))
    accuracy_max = np.max(np.array(performances))
    error_rate_A = np.mean(np.array(first_errors))
    error_rate_B = np.mean(np.array(second_errors))
    error_rate_C = np.mean(np.array(third_errors))

    csv_filename = "Exhaustive_test_results.csv"

    # Save the results to a CSV file
    with open(csv_filename, mode="a", newline="") as file:
        writer = csv.writer(file)
        
        # Write the header if the file is empty
        if file.tell() == 0:
            writer.writerow(["n", "m", "mean_accuracy", "std_accuracy", "min_accuracy", "max_accuracy", "mean_error_rate_A", "mean_error_rate_B", "mean_error_rate_C"])

        # Write the values
        writer.writerow([n, m, accuracy_mean, accuracy_std, accuracy_min, accuracy_max, error_rate_A, error_rate_B, error_rate_C])

    print(f"Results saved to {csv_filename}")